# ============================================================================
# NL2SQL 메타데이터 조회 쿼리 (Oracle)
# ============================================================================
#
# Oracle 특화 사항:
#   - 스키마 = 사용자 (nl2sql 사용자)
#   - NUMBER(1)이 BOOLEAN 역할
#   - CLOB 타입 사용
#   - JSON 지원 (Oracle 12c+)
#   - NVL 함수로 DB별 조건 우선 적용
# ============================================================================

metadataSchema: NL2SQL

queries:
  # ==========================================================================
  # 테이블 관계 조회  # ==========================================================================
  relationships:
    sql: |
      SELECT
        source_schema,
        source_table,
        source_column,
        target_schema,
        target_table,
        target_column,
        relationship_type,
        confidence_level,
        join_hint,
        polymorphic_type_column,
        polymorphic_type_value,
        UTL_RAW.CAST_TO_RAW(description) as description
      FROM table_relationships
      WHERE is_active = 1
      ORDER BY source_schema, source_table, source_column
    mapping:
      sourceSchema: source_schema
      sourceTable: source_table
      sourceColumn: source_column
      targetSchema: target_schema
      targetTable: target_table
      targetColumn: target_column
      relationshipType: relationship_type
      confidence: confidence_level
      joinHint: join_hint

  # ==========================================================================
  # 네이밍 컨벤션 조회
  # ==========================================================================
  namingConventions:
    sql: |
      SELECT
        convention_name,
        column_pattern,
        target_table_pattern,
        target_column_pattern,
        table_prefix_strip,
        table_suffix_strip,
        apply_pluralization,
        priority,
        apply_to_schemas,
        exclude_tables,
        UTL_RAW.CAST_TO_RAW(description) as description
      FROM naming_conventions
      WHERE is_active = 1
      ORDER BY priority
    mapping:
      name: convention_name
      columnPattern: column_pattern
      targetTablePattern: target_table_pattern
      targetColumnPattern: target_column_pattern
      applyPluralization: apply_pluralization
      priority: priority

  # ==========================================================================
  # 공통코드 테이블 설정 조회
  # ==========================================================================
  codeTables:
    sql: |
      SELECT
        code_table_name,
        table_schema,
        table_name,
        group_code_column,
        code_column,
        code_name_column,
        description_column,
        sort_order_column,
        active_flag_column,
        active_flag_value,
        additional_filter,
        locale_column,
        default_locale
      FROM code_tables
      WHERE is_active = 1
    mapping:
      codeTableName: code_table_name
      tableSchema: table_schema
      tableName: table_name
      groupCodeColumn: group_code_column
      codeColumn: code_column
      codeNameColumn: code_name_column
      descriptionColumn: description_column
      sortOrderColumn: sort_order_column
      activeFlagColumn: active_flag_column
      activeFlagValue: active_flag_value
      additionalFilter: additional_filter

  # ==========================================================================
  # 컬럼-코드 매핑 조회
  # ==========================================================================
  columnCodeMappings:
    sql: |
      SELECT
        target_schema,
        target_table,
        target_column,
        code_table_name,
        group_code,
        UTL_RAW.CAST_TO_RAW(display_name) as display_name,
        include_in_prompt
      FROM column_code_mapping
      WHERE is_active = 1
      ORDER BY target_schema, target_table, target_column
    mapping:
      targetSchema: target_schema
      targetTable: target_table
      targetColumn: target_column
      codeTableName: code_table_name
      groupCode: group_code
      displayName: display_name
      includeInPrompt: include_in_prompt

  # ==========================================================================
  # 코드 별칭 조회
  # ==========================================================================
  codeAliases:
    sql: |
      SELECT
        code_table_name,
        group_code,
        code_value,
        UTL_RAW.CAST_TO_RAW(alias) as alias,
        locale
      FROM code_aliases
      WHERE is_active = 1
    mapping:
      codeTableName: code_table_name
      groupCode: group_code
      codeValue: code_value
      alias: alias
      locale: locale

  # ==========================================================================
  # 용어집 조회 (Oracle용 SQL 조건 우선)
  # ==========================================================================
  glossaryTerms:
    sql: |
      SELECT
        term_code,
        UTL_RAW.CAST_TO_RAW(term) as term,
        category,
        sql_condition,
        sql_condition_pg,
        sql_condition_mysql,
        apply_to_tables,
        required_columns,
        UTL_RAW.CAST_TO_RAW(definition) as definition,
        UTL_RAW.CAST_TO_RAW(example_usage) as example_usage,
        priority
      FROM glossary_terms
      WHERE is_active = 1
      ORDER BY priority
    mapping:
      termCode: term_code
      term: term
      category: category
      sqlCondition: sql_condition
      sqlConditionPg: sql_condition_pg
      sqlConditionMysql: sql_condition_mysql
      applyToTables: apply_to_tables
      requiredColumns: required_columns
      definition: definition
      exampleUsage: example_usage
      priority: priority

  # ==========================================================================
  # 용어 별칭 조회
  # ==========================================================================
  glossaryAliases:
    sql: |
      SELECT
        term_code,
        UTL_RAW.CAST_TO_RAW(alias) as alias,
        locale,
        match_type
      FROM glossary_aliases
      WHERE is_active = 1
    mapping:
      termCode: term_code
      alias: alias
      locale: locale
      matchType: match_type

  # ==========================================================================
  # 용어 컨텍스트 조회
  # ==========================================================================
  glossaryContexts:
    sql: |
      SELECT
        term_code,
        context_schema,
        context_table,
        sql_condition,
        sql_condition_pg,
        sql_condition_mysql,
        required_columns,
        UTL_RAW.CAST_TO_RAW(context_definition) as context_definition
      FROM glossary_contexts
      WHERE is_active = 1
    mapping:
      termCode: term_code
      contextSchema: context_schema
      contextTable: context_table
      sqlCondition: sql_condition
      requiredColumns: required_columns
      contextDefinition: context_definition

  # ==========================================================================
  # 쿼리 패턴 조회 (Oracle용 템플릿 우선)
  # ==========================================================================
  queryPatterns:
    sql: |
      SELECT
        pattern_code,
        pattern_name,
        category,
        sql_template,
        sql_template_pg,
        sql_template_mysql,
        applicable_tables,
        required_columns,
        required_joins,
        match_score_threshold,
        priority,
        UTL_RAW.CAST_TO_RAW(description) as description,
        UTL_RAW.CAST_TO_RAW(example_input) as example_input,
        UTL_RAW.CAST_TO_RAW(example_output) as example_output
      FROM query_patterns
      WHERE is_active = 1
      ORDER BY priority
    mapping:
      patternCode: pattern_code
      patternName: pattern_name
      category: category
      sqlTemplate: sql_template
      sqlTemplatePg: sql_template_pg
      sqlTemplateMysql: sql_template_mysql
      applicableTables: applicable_tables
      requiredColumns: required_columns
      requiredJoins: required_joins
      matchScoreThreshold: match_score_threshold
      priority: priority
      description: description
      exampleInput: example_input
      exampleOutput: example_output

  # ==========================================================================
  # 패턴 파라미터 조회
  # ==========================================================================
  patternParameters:
    sql: |
      SELECT
        pattern_code,
        param_name,
        param_type,
        is_required,
        default_value,
        allowed_values,
        infer_from_keywords,
        infer_from_column_type,
        UTL_RAW.CAST_TO_RAW(description) as description,
        display_order
      FROM pattern_parameters
      WHERE is_active = 1
      ORDER BY pattern_code, display_order
    mapping:
      patternCode: pattern_code
      paramName: param_name
      paramType: param_type
      isRequired: is_required
      defaultValue: default_value
      allowedValues: allowed_values
      inferFromKeywords: infer_from_keywords
      inferFromColumnType: infer_from_column_type
      description: description
      displayOrder: display_order

  # ==========================================================================
  # 패턴 키워드 조회
  # ==========================================================================
  patternKeywords:
    sql: |
      SELECT
        pattern_code,
        UTL_RAW.CAST_TO_RAW(keyword) as keyword,
        locale,
        weight,
        match_type,
        is_required
      FROM pattern_keywords
      WHERE is_active = 1
    mapping:
      patternCode: pattern_code
      keyword: keyword
      locale: locale
      weight: weight
      matchType: match_type
      isRequired: is_required

# ============================================================================
# DDL: 메타데이터 테이블 자동 생성 (현재 사용자 스키마)
# ============================================================================
# Oracle은 CREATE TABLE IF NOT EXISTS를 지원하지 않으므로
# TypeScript에서 user_tables 조회 후 존재하지 않는 테이블만 생성
ddl:
  tables:
    - name: table_relationships
      createSql: |
        CREATE TABLE table_relationships (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          source_schema VARCHAR2(128) NOT NULL,
          source_table VARCHAR2(128) NOT NULL,
          source_column VARCHAR2(128) NOT NULL,
          target_schema VARCHAR2(128) NOT NULL,
          target_table VARCHAR2(128) NOT NULL,
          target_column VARCHAR2(128) NOT NULL,
          relationship_type VARCHAR2(20) DEFAULT 'MANY_TO_ONE' NOT NULL,
          confidence_level VARCHAR2(10) DEFAULT 'HIGH' NOT NULL,
          join_hint VARCHAR2(20),
          polymorphic_type_column VARCHAR2(128),
          polymorphic_type_value VARCHAR2(128),
          description CLOB,
          business_context CLOB,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          created_by VARCHAR2(100),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_by VARCHAR2(100),
          CONSTRAINT uk_table_rel UNIQUE (source_schema, source_table, source_column,
                                          target_schema, target_table, target_column),
          CONSTRAINT chk_rel_type CHECK (relationship_type IN ('ONE_TO_ONE','ONE_TO_MANY','MANY_TO_ONE','MANY_TO_MANY')),
          CONSTRAINT chk_conf_level CHECK (confidence_level IN ('HIGH','MEDIUM','LOW')),
          CONSTRAINT chk_join_hint CHECK (join_hint IS NULL OR join_hint IN ('INNER','LEFT','RIGHT')),
          CONSTRAINT chk_rel_active CHECK (is_active IN (0, 1))
        )
      indexes:
        - CREATE INDEX idx_rel_source ON table_relationships(source_schema, source_table)
        - CREATE INDEX idx_rel_target ON table_relationships(target_schema, target_table)
        - CREATE INDEX idx_rel_active ON table_relationships(is_active)

    - name: naming_conventions
      createSql: |
        CREATE TABLE naming_conventions (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          convention_name VARCHAR2(100) NOT NULL,
          column_pattern VARCHAR2(255) NOT NULL,
          target_table_pattern VARCHAR2(255) NOT NULL,
          target_column_pattern VARCHAR2(255) DEFAULT 'id' NOT NULL,
          table_prefix_strip VARCHAR2(50),
          table_suffix_strip VARCHAR2(50),
          apply_pluralization NUMBER(1) DEFAULT 1,
          priority NUMBER DEFAULT 100 NOT NULL,
          apply_to_schemas CLOB,
          exclude_tables CLOB,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          description CLOB,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_naming_conv UNIQUE (convention_name),
          CONSTRAINT chk_naming_active CHECK (is_active IN (0, 1)),
          CONSTRAINT chk_naming_plural CHECK (apply_pluralization IN (0, 1))
        )
      indexes:
        - CREATE INDEX idx_naming_priority ON naming_conventions(priority, is_active)

    - name: code_tables
      createSql: |
        CREATE TABLE code_tables (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          code_table_name VARCHAR2(100) NOT NULL,
          table_schema VARCHAR2(128) NOT NULL,
          table_name VARCHAR2(128) NOT NULL,
          group_code_column VARCHAR2(128) NOT NULL,
          code_column VARCHAR2(128) NOT NULL,
          code_name_column VARCHAR2(128) NOT NULL,
          description_column VARCHAR2(128),
          sort_order_column VARCHAR2(128),
          active_flag_column VARCHAR2(128),
          active_flag_value VARCHAR2(50),
          additional_filter CLOB,
          locale_column VARCHAR2(128),
          default_locale VARCHAR2(10) DEFAULT 'ko',
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          description CLOB,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_code_table_name UNIQUE (code_table_name),
          CONSTRAINT uk_code_table_loc UNIQUE (table_schema, table_name),
          CONSTRAINT chk_code_active CHECK (is_active IN (0, 1))
        )

    - name: column_code_mapping
      createSql: |
        CREATE TABLE column_code_mapping (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          target_schema VARCHAR2(128) NOT NULL,
          target_table VARCHAR2(128) NOT NULL,
          target_column VARCHAR2(128) NOT NULL,
          code_table_name VARCHAR2(100) NOT NULL,
          group_code VARCHAR2(100) NOT NULL,
          display_name VARCHAR2(200),
          include_in_prompt NUMBER(1) DEFAULT 1 NOT NULL,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          description CLOB,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_col_code_mapping UNIQUE (target_schema, target_table, target_column),
          CONSTRAINT chk_col_mapping_active CHECK (is_active IN (0, 1)),
          CONSTRAINT chk_col_mapping_prompt CHECK (include_in_prompt IN (0, 1)),
          CONSTRAINT fk_col_mapping_code_table
            FOREIGN KEY (code_table_name) REFERENCES code_tables(code_table_name) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_col_mapping_table ON column_code_mapping(target_schema, target_table)
        - CREATE INDEX idx_col_mapping_code ON column_code_mapping(code_table_name, group_code)

    - name: code_aliases
      createSql: |
        CREATE TABLE code_aliases (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          code_table_name VARCHAR2(100) NOT NULL,
          group_code VARCHAR2(100) NOT NULL,
          code_value VARCHAR2(100) NOT NULL,
          alias VARCHAR2(200) NOT NULL,
          locale VARCHAR2(10) DEFAULT 'ko',
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_code_alias UNIQUE (code_table_name, group_code, alias, locale),
          CONSTRAINT chk_alias_active CHECK (is_active IN (0, 1)),
          CONSTRAINT fk_alias_code_table
            FOREIGN KEY (code_table_name) REFERENCES code_tables(code_table_name) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_code_alias_lookup ON code_aliases(alias, locale)

    - name: glossary_terms
      createSql: |
        CREATE TABLE glossary_terms (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          term_code VARCHAR2(100) NOT NULL,
          term VARCHAR2(200) NOT NULL,
          category VARCHAR2(50),
          sql_condition CLOB NOT NULL,
          sql_condition_pg CLOB,
          sql_condition_mysql CLOB,
          apply_to_tables CLOB,
          required_columns CLOB NOT NULL,
          definition CLOB NOT NULL,
          example_usage CLOB,
          example_sql CLOB,
          business_context CLOB,
          priority NUMBER DEFAULT 100 NOT NULL,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          created_by VARCHAR2(100),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_by VARCHAR2(100),
          CONSTRAINT uk_glossary_term_code UNIQUE (term_code),
          CONSTRAINT chk_glossary_category CHECK (category IS NULL OR category IN (
            'CUSTOMER','ORDER','PRODUCT','DATE','STATUS','METRIC','GENERAL'
          )),
          CONSTRAINT chk_glossary_active CHECK (is_active IN (0, 1))
        )
      indexes:
        - CREATE INDEX idx_glossary_term ON glossary_terms(term)
        - CREATE INDEX idx_glossary_category ON glossary_terms(category)
        - CREATE INDEX idx_glossary_active ON glossary_terms(is_active)

    - name: glossary_aliases
      createSql: |
        CREATE TABLE glossary_aliases (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          term_code VARCHAR2(100) NOT NULL,
          alias VARCHAR2(200) NOT NULL,
          locale VARCHAR2(10) DEFAULT 'ko',
          match_type VARCHAR2(20) DEFAULT 'EXACT' NOT NULL,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_glossary_alias UNIQUE (term_code, alias, locale),
          CONSTRAINT chk_alias_match_type CHECK (match_type IN ('EXACT','CONTAINS','STARTS_WITH','ENDS_WITH','REGEX')),
          CONSTRAINT chk_g_alias_active CHECK (is_active IN (0, 1)),
          CONSTRAINT fk_glossary_alias_term
            FOREIGN KEY (term_code) REFERENCES glossary_terms(term_code) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_glossary_alias_lookup ON glossary_aliases(alias, locale)

    - name: glossary_contexts
      createSql: |
        CREATE TABLE glossary_contexts (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          term_code VARCHAR2(100) NOT NULL,
          context_schema VARCHAR2(128) NOT NULL,
          context_table VARCHAR2(128) NOT NULL,
          sql_condition CLOB NOT NULL,
          sql_condition_pg CLOB,
          sql_condition_mysql CLOB,
          required_columns CLOB NOT NULL,
          context_definition CLOB,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          CONSTRAINT uk_glossary_context UNIQUE (term_code, context_schema, context_table),
          CONSTRAINT chk_g_ctx_active CHECK (is_active IN (0, 1)),
          CONSTRAINT fk_glossary_ctx_term
            FOREIGN KEY (term_code) REFERENCES glossary_terms(term_code) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_glossary_ctx_table ON glossary_contexts(context_schema, context_table)

    - name: query_patterns
      createSql: |
        CREATE TABLE query_patterns (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          pattern_code VARCHAR2(100) NOT NULL,
          pattern_name VARCHAR2(200) NOT NULL,
          category VARCHAR2(50),
          sql_template CLOB NOT NULL,
          sql_template_pg CLOB,
          sql_template_mysql CLOB,
          applicable_tables CLOB,
          required_columns CLOB,
          required_joins CLOB,
          match_score_threshold NUMBER DEFAULT 70 NOT NULL,
          priority NUMBER DEFAULT 100 NOT NULL,
          description CLOB NOT NULL,
          use_case CLOB,
          example_input CLOB,
          example_output CLOB,
          performance_notes CLOB,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          usage_count NUMBER DEFAULT 0 NOT NULL,
          last_used_at TIMESTAMP WITH TIME ZONE,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          created_by VARCHAR2(100),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
          updated_by VARCHAR2(100),
          CONSTRAINT uk_pattern_code UNIQUE (pattern_code),
          CONSTRAINT chk_pattern_category CHECK (category IS NULL OR category IN (
            'AGGREGATION','REPORT','LOOKUP','ANALYSIS','COMPARISON','TREND','RANKING','GENERAL'
          )),
          CONSTRAINT chk_match_score CHECK (match_score_threshold BETWEEN 0 AND 100),
          CONSTRAINT chk_pattern_active CHECK (is_active IN (0, 1))
        )
      indexes:
        - CREATE INDEX idx_pattern_category ON query_patterns(category)
        - CREATE INDEX idx_pattern_active ON query_patterns(is_active)
        - CREATE INDEX idx_pattern_priority ON query_patterns(priority)

    - name: pattern_parameters
      createSql: |
        CREATE TABLE pattern_parameters (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          pattern_code VARCHAR2(100) NOT NULL,
          param_name VARCHAR2(100) NOT NULL,
          param_type VARCHAR2(30) NOT NULL,
          is_required NUMBER(1) DEFAULT 1 NOT NULL,
          default_value CLOB,
          allowed_values CLOB,
          validation_pattern VARCHAR2(255),
          infer_from_keywords CLOB,
          infer_from_column_type VARCHAR2(50),
          description CLOB,
          example_value CLOB,
          display_order NUMBER DEFAULT 0 NOT NULL,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          CONSTRAINT uk_pattern_param UNIQUE (pattern_code, param_name),
          CONSTRAINT chk_param_type CHECK (param_type IN ('COLUMN','TABLE','VALUE','DATE','NUMBER','EXPRESSION','CONDITION')),
          CONSTRAINT chk_param_required CHECK (is_required IN (0, 1)),
          CONSTRAINT chk_param_active CHECK (is_active IN (0, 1)),
          CONSTRAINT fk_param_pattern
            FOREIGN KEY (pattern_code) REFERENCES query_patterns(pattern_code) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_pattern_params ON pattern_parameters(pattern_code)

    - name: pattern_keywords
      createSql: |
        CREATE TABLE pattern_keywords (
          id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
          pattern_code VARCHAR2(100) NOT NULL,
          keyword VARCHAR2(100) NOT NULL,
          locale VARCHAR2(10) DEFAULT 'ko',
          weight NUMBER DEFAULT 10 NOT NULL,
          match_type VARCHAR2(20) DEFAULT 'CONTAINS' NOT NULL,
          is_required NUMBER(1) DEFAULT 0 NOT NULL,
          is_active NUMBER(1) DEFAULT 1 NOT NULL,
          CONSTRAINT chk_kw_weight CHECK (weight BETWEEN 1 AND 100),
          CONSTRAINT chk_kw_match_type CHECK (match_type IN ('EXACT','CONTAINS','STARTS_WITH','ENDS_WITH','REGEX')),
          CONSTRAINT chk_kw_required CHECK (is_required IN (0, 1)),
          CONSTRAINT chk_kw_active CHECK (is_active IN (0, 1)),
          CONSTRAINT fk_kw_pattern
            FOREIGN KEY (pattern_code) REFERENCES query_patterns(pattern_code) ON DELETE CASCADE
        )
      indexes:
        - CREATE INDEX idx_pattern_kw_lookup ON pattern_keywords(keyword, locale)
        - CREATE INDEX idx_pattern_kw_pattern ON pattern_keywords(pattern_code)
