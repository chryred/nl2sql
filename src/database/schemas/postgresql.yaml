# PostgreSQL Schema Queries
# PostgreSQL 데이터베이스에서 스키마 정보를 추출하기 위한 쿼리 정의

# 제외할 시스템 스키마 목록
excludeSchemas:
  - information_schema
  - pg_catalog
  - pg_toast
  - pg_temp_1
  - pg_toast_temp_1

queries:
  # 사용 가능한 스키마 목록 조회
  schemas:
    sql: |
      SELECT schema_name
      FROM information_schema.schemata
      ORDER BY schema_name
    mapping:
      name: schema_name

  # 모든 스키마의 테이블 목록 조회 (시스템 스키마 제외)
  tables:
    sql: |
      SELECT
        t.table_schema as schema_name,
        t.table_name,
        obj_description((quote_ident(t.table_schema) || '.' || quote_ident(t.table_name))::regclass, 'pg_class') as table_comment
      FROM information_schema.tables t
      WHERE t.table_type = 'BASE TABLE'
      ORDER BY t.table_schema, t.table_name
    mapping:
      schemaName: schema_name
      name: table_name
      comment: table_comment

  # 특정 테이블의 컬럼 정보 조회
  columns:
    sql: |
      SELECT
        c.column_name,
        c.data_type,
        c.is_nullable,
        c.column_default,
        CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as is_primary_key,
        col_description((quote_ident(c.table_schema) || '.' || quote_ident(c.table_name))::regclass, c.ordinal_position) as column_comment
      FROM information_schema.columns c
      LEFT JOIN (
        SELECT ku.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage ku
          ON tc.constraint_name = ku.constraint_name
          AND tc.table_schema = ku.table_schema
        WHERE tc.table_name = :tableName
          AND tc.table_schema = :schemaName
          AND tc.constraint_type = 'PRIMARY KEY'
      ) pk ON c.column_name = pk.column_name
      WHERE c.table_name = :tableName
        AND c.table_schema = :schemaName
      ORDER BY c.ordinal_position
    params:
      - tableName
      - schemaName

  # 특정 테이블의 외래키 정보 조회
  foreignKeys:
    sql: |
      SELECT
        kcu.column_name,
        ccu.table_schema AS foreign_schema_name,
        ccu.table_name AS foreign_table_name,
        ccu.column_name AS foreign_column_name
      FROM information_schema.table_constraints AS tc
      JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      JOIN information_schema.constraint_column_usage AS ccu
        ON ccu.constraint_name = tc.constraint_name
        AND ccu.table_schema = tc.table_schema
      WHERE tc.constraint_type = 'FOREIGN KEY'
        AND tc.table_name = :tableName
        AND tc.table_schema = :schemaName
    params:
      - tableName
      - schemaName

  # 특정 테이블의 제약조건 정보 조회
  constraints:
    sql: |
      SELECT
        tc.constraint_name,
        tc.constraint_type,
        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns,
        pg_get_constraintdef(pgc.oid) as definition
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      LEFT JOIN pg_constraint pgc
        ON pgc.conname = tc.constraint_name
      WHERE tc.table_name = :tableName
        AND tc.table_schema = :schemaName
      GROUP BY tc.constraint_name, tc.constraint_type, pgc.oid
      ORDER BY tc.constraint_type, tc.constraint_name
    params:
      - tableName
      - schemaName

  # 특정 테이블의 인덱스 정보 조회
  indexes:
    sql: |
      SELECT
        i.relname as index_name,
        array_agg(a.attname ORDER BY x.ordinality) as columns,
        ix.indisunique as is_unique,
        am.amname as index_type
      FROM pg_class t
      JOIN pg_index ix ON t.oid = ix.indrelid
      JOIN pg_class i ON i.oid = ix.indexrelid
      JOIN pg_am am ON i.relam = am.oid
      JOIN pg_namespace n ON n.oid = t.relnamespace
      CROSS JOIN LATERAL unnest(ix.indkey) WITH ORDINALITY AS x(attnum, ordinality)
      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = x.attnum
      WHERE t.relname = :tableName
        AND n.nspname = :schemaName
        AND NOT ix.indisprimary
      GROUP BY i.relname, ix.indisunique, am.amname
      ORDER BY i.relname
    params:
      - tableName
      - schemaName

  # 벌크: 모든 테이블의 컬럼 정보 조회
  allColumns:
    sql: |
      SELECT
        c.table_schema as schema_name,
        c.table_name,
        c.column_name,
        c.data_type,
        c.is_nullable,
        c.column_default,
        CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as is_primary_key,
        col_description((quote_ident(c.table_schema) || '.' || quote_ident(c.table_name))::regclass, c.ordinal_position) as column_comment
      FROM information_schema.columns c
      LEFT JOIN (
        SELECT ku.table_schema, ku.table_name, ku.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage ku
          ON tc.constraint_name = ku.constraint_name
          AND tc.table_schema = ku.table_schema
        WHERE tc.constraint_type = 'PRIMARY KEY'
      ) pk ON c.table_schema = pk.table_schema
        AND c.table_name = pk.table_name
        AND c.column_name = pk.column_name
      WHERE c.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'pg_temp_1', 'pg_toast_temp_1')
      ORDER BY c.table_schema, c.table_name, c.ordinal_position
    optional: true

  # 벌크: 모든 테이블의 외래키 정보 조회
  allForeignKeys:
    sql: |
      SELECT
        tc.table_schema as schema_name,
        tc.table_name,
        kcu.column_name,
        ccu.table_schema AS foreign_schema_name,
        ccu.table_name AS foreign_table_name,
        ccu.column_name AS foreign_column_name
      FROM information_schema.table_constraints AS tc
      JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      JOIN information_schema.constraint_column_usage AS ccu
        ON ccu.constraint_name = tc.constraint_name
        AND ccu.table_schema = tc.table_schema
      WHERE tc.constraint_type = 'FOREIGN KEY'
        AND tc.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'pg_temp_1', 'pg_toast_temp_1')
    optional: true

  # 벌크: 모든 테이블의 제약조건 정보 조회
  allConstraints:
    sql: |
      SELECT
        tc.table_schema as schema_name,
        tc.table_name,
        tc.constraint_name,
        tc.constraint_type,
        array_agg(kcu.column_name ORDER BY kcu.ordinal_position) as columns,
        pg_get_constraintdef(pgc.oid) as definition
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      LEFT JOIN pg_constraint pgc
        ON pgc.conname = tc.constraint_name
      WHERE tc.table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'pg_temp_1', 'pg_toast_temp_1')
      GROUP BY tc.table_schema, tc.table_name, tc.constraint_name, tc.constraint_type, pgc.oid
      ORDER BY tc.table_schema, tc.table_name, tc.constraint_type, tc.constraint_name
    optional: true

  # 벌크: 모든 테이블의 인덱스 정보 조회
  allIndexes:
    sql: |
      SELECT
        n.nspname as schema_name,
        t.relname as table_name,
        i.relname as index_name,
        array_agg(a.attname ORDER BY x.ordinality) as columns,
        ix.indisunique as is_unique,
        am.amname as index_type
      FROM pg_class t
      JOIN pg_index ix ON t.oid = ix.indrelid
      JOIN pg_class i ON i.oid = ix.indexrelid
      JOIN pg_am am ON i.relam = am.oid
      JOIN pg_namespace n ON n.oid = t.relnamespace
      CROSS JOIN LATERAL unnest(ix.indkey) WITH ORDINALITY AS x(attnum, ordinality)
      JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = x.attnum
      WHERE n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'pg_temp_1', 'pg_toast_temp_1')
        AND NOT ix.indisprimary
      GROUP BY n.nspname, t.relname, i.relname, ix.indisunique, am.amname
      ORDER BY n.nspname, t.relname, i.relname
    optional: true

  # 최근 쿼리 패턴 조회 (pg_stat_statements 확장 필요)
  recentQueries:
    sql: |
      SELECT
        query,
        calls as call_count,
        ROUND(mean_exec_time::numeric, 2) as avg_time_ms
      FROM pg_stat_statements
      WHERE dbid = (SELECT oid FROM pg_database WHERE datname = current_database())
        AND query NOT LIKE '%pg_stat_statements%'
        AND query NOT LIKE 'BEGIN%'
        AND query NOT LIKE 'COMMIT%'
        AND query NOT LIKE 'SET %'
      ORDER BY calls DESC
      LIMIT 20
    optional: true
